npm init -y: cria o package.json instantaneamente aceitando todos os valores padrão, o que economiza tempo ao iniciar um
                projeto do zero.
Após o comando, é interessante adicionar nesse package.json:
	* "type": module,
	* "main": "build/index.js"
Ele fica assim:
{
    "name": "estudo-typescript", --> nome do projeto no ecossistema NodeJs
    "version": "1.0.0", --> controla a versão atual do software
    "description": "Estudo de Typescript com NodeJS.", --> resumo do objetivo do projeto
    "main": "build/index.js", --> define qual arquivo será executado quando alguém importar seu pacote ou quando você
                                    rodar o comando de início após a compilação -- executa scripts NodeJS puros.
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "build": "tsc", --> invoca o compilador do TypeScript para transformar seus arquivos .ts em .js dentro da pasta
                                de saída definida
        "dev": "tsx src/index.ts", --> usa a biblioteca tsx para executar seu código TypeScript diretamente em tempo de
                                    desenvolvimento, sem precisar compilar manualmente a cada mudança
        "start": "node ." --> executa o projeto compilado (definido em main) usando NodeJS puro.
    },
    "repository": {
        "type": "git",
        "url": "git+https://github.com/naraazi/estudo-typescript.git"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "type": "module", --> informa ao NodeJS que estamos usando ECMAScript Modules (ESM),
                            permitindo o uso de import/export em vez de require (prática mais moderna)
    "bugs": {
        "url": "https://github.com/naraazi/estudo-typescript/issues"
    },
    "homepage": "https://github.com/naraazi/estudo-typescript#readme",
    "devDependencies": {
        "@types/node": "^25.0.3", --> fornece as definições de tipos para as APIs nativas do Node.js (como fs, path,
                                        http)
        "tsx": "^4.21.0", --> executor rápido que permite rodar arquivos TS diretamente no Node
        "typescript": "^5.9.3" --> núcleo que permite converter o código TS para JS
    }
}


npm install -D: instala pacotes e os registra como "dependências de desenvolvimento". Isso é crucial porque o TypeScript
                    não é necessário para rodar o app em produção, apenas para construí-lo.
É importante baixar:
	* typescript
	* tsx
	* @types/node

É importante adicionar esses scripts ao package.json:
    * "build": "tsc",
    * "dev": "tsx src/index.ts",
    * "start": "node ."

tsconfig.json: dita como o compilador deve se comportar.
Os scripts que são interessantes existir são:
{
    "compilerOptions": {
        "esModuleInterop": true, --> garante que você consiga importar bibliotecas que não foram escritas em ESM (usando
                                        import em vez de require) sem erros de compatibilidade
        "skipLibCheck": true, --> faz o compilador ignorar a checagem de tipos dentro das pastas node_modules
                                    Isso torna a compilação muito mais rápida
        "strict": true, --> ativa o modo de segurança máxima. O TS exigirá que você defina tipos corretamente e não
                                permitirá comportamentos ambíguos (como variáveis que podem ser null sem aviso)
        "lib": ["ESNext"],
        "target": "esnext", --> define para qual versão do JavaScript seu código será convertido. "ESNext" foca nas
                                    versões mais modernas suportadas pelo Node.js atual
        "module": "nodenext", --> diz ao TS como lidar com os módulos de importação, garantindo que ele siga as regras
                                    mais recentes do Node.js.
        "moduleResolution": "nodenext",

        "rootDir": "src", --> informa ao compilador onde está o seu código-fonte original. Ele só vai olhar para o que
                                estiver dentro da pasta src
        "outDir": "build" --> define para onde o código JavaScript convertido deve ir.
                                É a pasta que você enviaria para um servidor de produção
    },
    "include": ["src"], --> especifica explicitamente que apenas os arquivos dentro de src devem ser compilados
    "exclude": ["node_modules"] --> garante que o compilador nunca tente processar as bibliotecas externas, evitando
                                        erros e lentidão
}

Quando há a necessidade de instalar pacotes, sempre uma correção é necessária.
Por exemplo:   
    * npm install next@13.1.6 react@18.2.0 react-dom@18.2.0: em JS apenas isso bastaria;
    * npm install -D typescript @types/node @types/react @types/react-dom: mas como é TS, isso aqui também deve ser
        instalado.

O comando que inicia o tsconfig.json automaticamente é: npx tsc --init
    * npx: como foi instalado o typescript como uma dependência de desenvolvimento (-D), o comando tsc não está
        disponível globalmente no terminal. O npx localiza o executável dentro da pasta node_modules e o executa.
    * tsc --init: diz ao compilador do TypeScript: "Crie um arquivo de configuração inicial baseado nos padrões
        recomendados".
